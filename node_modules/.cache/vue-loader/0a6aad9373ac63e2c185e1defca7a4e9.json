{"remainingRequest":"E:\\demo\\pikaz-excel-js\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!E:\\demo\\pikaz-excel-js\\src\\plugin\\excelExport\\excelExport.vue?vue&type=script&lang=js&","dependencies":[{"path":"E:\\demo\\pikaz-excel-js\\src\\plugin\\excelExport\\excelExport.vue","mtime":1610165480628},{"path":"E:\\demo\\pikaz-excel-js\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\demo\\pikaz-excel-js\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"E:\\demo\\pikaz-excel-js\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\demo\\pikaz-excel-js\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KDQppbXBvcnQgeyBzYXZlQXMgfSBmcm9tICdmaWxlLXNhdmVyJw0KaW1wb3J0IFhMU1ggZnJvbSAncGlrYXoteGxzeC1zdHlsZScNCmV4cG9ydCBkZWZhdWx0IHsNCiAgcHJvcHM6IHsNCiAgICAvLyDmlofku7bnsbvlnosNCiAgICBib29rVHlwZTogew0KICAgICAgdHlwZTogU3RyaW5nLA0KICAgICAgZGVmYXVsdDogJ3hsc3gnDQogICAgfSwNCiAgICAvLyDmlofku7blkI0NCiAgICBmaWxlbmFtZTogew0KICAgICAgdHlwZTogU3RyaW5nLA0KICAgICAgZGVmYXVsdDogJ2V4Y2VsJw0KICAgIH0sDQogICAgLy8g5piv5ZCm5omL5Yqo5a+85Ye6DQogICAgbWFudWFsOiB7DQogICAgICB0eXBlOiBCb29sZWFuLA0KICAgICAgZGVmYXVsdDogZmFsc2UNCiAgICB9LA0KICAgIC8vIOihqOagvOmFjee9rg0KICAgIHNoZWV0OiB7DQogICAgICB0eXBlOiBBcnJheSwNCiAgICAgIGRlZmF1bHQ6ICgpID0+IHsNCiAgICAgICAgcmV0dXJuIFtdDQogICAgICB9DQogICAgfSwNCiAgICAvLyDlpITnkIbmlbDmja7liY0NCiAgICBiZWZvcmVTdGFydDogew0KICAgICAgdHlwZTogRnVuY3Rpb24sDQogICAgICAvLyBib29rVHlwZTrmlofku7bnsbvlnossZmlsZW5hbWU65paH5Lu25ZCNLHNoZWV0OuihqOagvOaVsOaNrg0KICAgICAgZGVmYXVsdDogKGJvb2tUeXBlLCBmaWxlbmFtZSwgc2hlZXQpID0+IHsgfQ0KICAgIH0sDQogICAgLy8g5a+85Ye65YmNDQogICAgYmVmb3JlRXhwb3J0OiB7DQogICAgICB0eXBlOiBGdW5jdGlvbiwNCiAgICAgIC8vIGZpbGVuYW1lOuaWh+S7tuWQjSxzaGVldDrooajmoLzmlbDmja4sYmxvYjrmlofku7bmtYENCiAgICAgIGRlZmF1bHQ6IChib29rVHlwZSwgZmlsZW5hbWUsIGJsb2IpID0+IHsgfQ0KICAgIH0sDQogICAgLy8g5a+85Ye66ZSZ6K+vDQogICAgb25FcnJvcjogew0KICAgICAgdHlwZTogRnVuY3Rpb24sDQogICAgICAvLyBlcnI66ZSZ6K+v5L+h5oGvDQogICAgICBkZWZhdWx0OiAoZXJyKSA9PiB7IH0NCiAgICB9DQogIH0sDQogIGNvbXBvbmVudHM6IHt9LA0KICBkYXRhICgpIHsNCiAgICByZXR1cm4gew0KICAgICAgLy8g6buY6K6k6YWN572uDQogICAgICBkZWZhdWx0OiB7DQogICAgICAgIHNoZWV0TmFtZTogJ3NoZWV0JywNCiAgICAgICAgZ2xvYmFsU3R5bGU6IHsNCiAgICAgICAgICBib3JkZXI6IHsNCiAgICAgICAgICAgIHRvcDogew0KICAgICAgICAgICAgICBzdHlsZTogJ3RoaW4nLA0KICAgICAgICAgICAgICBjb2xvcjogeyByZ2I6ICIwMDAwMDAiIH0NCiAgICAgICAgICAgIH0sDQogICAgICAgICAgICBib3R0b206IHsNCiAgICAgICAgICAgICAgc3R5bGU6ICd0aGluJywNCiAgICAgICAgICAgICAgY29sb3I6IHsgcmdiOiAiMDAwMDAwIiB9DQogICAgICAgICAgICB9LA0KICAgICAgICAgICAgbGVmdDogew0KICAgICAgICAgICAgICBzdHlsZTogJ3RoaW4nLA0KICAgICAgICAgICAgICBjb2xvcjogeyByZ2I6ICIwMDAwMDAiIH0NCiAgICAgICAgICAgIH0sDQogICAgICAgICAgICByaWdodDogew0KICAgICAgICAgICAgICBzdHlsZTogJ3RoaW4nLA0KICAgICAgICAgICAgICBjb2xvcjogeyByZ2I6ICIwMDAwMDAiIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9LA0KICAgICAgICAgIGZvbnQ6IHsNCiAgICAgICAgICAgIG5hbWU6ICflrovkvZMnLA0KICAgICAgICAgICAgc3o6IDEyLA0KICAgICAgICAgICAgY29sb3I6IHsgcmdiOiAiMDAwMDAwIiB9LA0KICAgICAgICAgICAgYm9sZDogZmFsc2UsDQogICAgICAgICAgICBpdGFsaWM6IGZhbHNlLA0KICAgICAgICAgICAgdW5kZXJsaW5lOiBmYWxzZSwNCiAgICAgICAgICAgIHNoYWRvdzogZmFsc2UNCiAgICAgICAgICB9LA0KICAgICAgICAgIGFsaWdubWVudDogew0KICAgICAgICAgICAgaG9yaXpvbnRhbDogImNlbnRlciIsDQogICAgICAgICAgICB2ZXJ0aWNhbDogImNlbnRlciIsDQogICAgICAgICAgICB3cmFwVGV4dDogZmFsc2UNCiAgICAgICAgICB9LA0KICAgICAgICAgIGZpbGw6IHsNCiAgICAgICAgICAgIGZnQ29sb3I6IHsgcmdiOiAiZmZmZmZmIiB9LA0KICAgICAgICAgIH0NCiAgICAgICAgfSwNCiAgICAgIH0sDQogICAgICAvLyDmnprkuL7nsbsNCiAgICAgIGVudW06IHsNCiAgICAgICAgLy8g5paH5Lu257G75Z6LDQogICAgICAgIGJvb2tUeXBlOiBbJ3hsc3gnLCAneGxzJ10NCiAgICAgIH0NCiAgICB9DQogIH0sDQogIGNyZWF0ZWQgKCkgew0KICB9LA0KICBtb3VudGVkICgpIHsNCiAgfSwNCiAgbWV0aG9kczogew0KICAgIC8qKg0KICAgICAqIEBuYW1lOiDlr7zlh7pleGNlbOWHveaVsA0KICAgICAqIEBwYXJhbSB7dHlwZX0gDQogICAgICogQHJldHVybjogDQogICAgICovDQogICAgcGlrYUV4cG9ydEV4Y2VsICgpIHsNCiAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsNCiAgICAgICAgdGhpcy5leHBvcnRFeGNlbCgpDQogICAgICB9KQ0KICAgIH0sDQogICAgLyoqDQogICAgICogQG5hbWU65a+85Ye6ZXhjZWwgDQogICAgICogQHBhcmFtIHt0eXBlfSANCiAgICAgKiBAcmV0dXJuOiANCiAgICAgKi8NCiAgICBleHBvcnRFeGNlbCAoKSB7DQogICAgICAvLyDlpITnkIbmlbDmja7liY0NCiAgICAgIGNvbnN0IGJlZm9yZVN0YXJ0ID0gdGhpcy5iZWZvcmVTdGFydCh0aGlzLmJvb2tUeXBlLCB0aGlzLmZpbGVuYW1lLCB0aGlzLnNoZWV0KQ0KICAgICAgaWYgKGJlZm9yZVN0YXJ0ID09PSBmYWxzZSkgew0KICAgICAgICByZXR1cm4NCiAgICAgIH0NCiAgICAgIGlmICghdGhpcy5zaGVldCB8fCB0aGlzLnNoZWV0Lmxlbmd0aCA8PSAwKSB7DQogICAgICAgIHRoaXMub25FcnJvcignVGFibGUgZGF0YSBjYW5ub3QgYmUgZW1wdHknKQ0KICAgICAgICByZXR1cm4NCiAgICAgIH0NCiAgICAgIGNvbnN0IHdiID0gdGhpcy5Xb3JrYm9vaygpDQogICAgICB0aGlzLnNoZWV0LmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7DQogICAgICAgIGxldCB7DQogICAgICAgICAgLy8g5qCH6aKYDQogICAgICAgICAgdGl0bGUsDQogICAgICAgICAgLy8g6KGo5aS0DQogICAgICAgICAgdEhlYWRlciwNCiAgICAgICAgICAvLyDlpJrnuqfooajlpLQNCiAgICAgICAgICBtdWx0aUhlYWRlciwNCiAgICAgICAgICAvLyDooajmoLzmlbDmja4NCiAgICAgICAgICB0YWJsZSwNCiAgICAgICAgICAvLyDlkIjlubbpobkNCiAgICAgICAgICBtZXJnZXMsDQogICAgICAgICAgLy8g5pWw5o2u6ZSu5YC8DQogICAgICAgICAga2V5cywNCiAgICAgICAgICAvLyDliJflrr0NCiAgICAgICAgICBjb2xXaWR0aCwNCiAgICAgICAgICAvLyDooajlkI0NCiAgICAgICAgICBzaGVldE5hbWUsDQogICAgICAgICAgLy8g5YWo5bGA5qC35byPDQogICAgICAgICAgZ2xvYmFsU3R5bGUsDQogICAgICAgICAgLy8g5Y2V5YWD5qC85qC35byPDQogICAgICAgICAgY2VsbFN0eWxlDQogICAgICAgIH0gPSBpdGVtDQogICAgICAgIHNoZWV0TmFtZSA9IHNoZWV0TmFtZSB8fCB0aGlzLmRlZmF1bHQuc2hlZXROYW1lDQogICAgICAgIC8vIOm7mOiupOWFqOWxgOagt+W8j+imhueblg0KICAgICAgICBjb25zdCBkZ1N0eWxlID0gdGhpcy5kZWZhdWx0Lmdsb2JhbFN0eWxlDQogICAgICAgIGlmIChnbG9iYWxTdHlsZSkgew0KICAgICAgICAgIE9iamVjdC5rZXlzKGRnU3R5bGUpLmZvckVhY2goa2V5ID0+IHsNCiAgICAgICAgICAgIGdsb2JhbFN0eWxlW2tleV0gPSB7IC4uLmRnU3R5bGVba2V5XSwgLi4uZ2xvYmFsU3R5bGVba2V5XSB9DQogICAgICAgICAgfSkNCiAgICAgICAgfSBlbHNlIHsNCiAgICAgICAgICBnbG9iYWxTdHlsZSA9IGRnU3R5bGUNCiAgICAgICAgfQ0KICAgICAgICAvLyDlpITnkIbmoIfpopjmoLzlvI8NCiAgICAgICAgaWYgKHRpdGxlIHx8IHRpdGxlID09PSAwIHx8IHRpdGxlID09PSAnJykgew0KICAgICAgICAgIC8vIOWPluihqOWktOOAgeWkmue6p+ihqOWktOS4reeahOacgOWkp+WAvA0KICAgICAgICAgIGNvbnN0IHRIZWFkZXJMZW5ndGggPSB0SGVhZGVyICYmIHRIZWFkZXIubGVuZ3RoIHx8IDANCiAgICAgICAgICBjb25zdCBtdWx0aUhlYWRlckxlbmd0aCA9IG11bHRpSGVhZGVyICYmIE1hdGgubWF4KC4uLm11bHRpSGVhZGVyLm1hcChtID0+IG0ubGVuZ3RoKSkgfHwgMA0KICAgICAgICAgIGNvbnN0IHRpdGxlTGVuZ3RoID0gTWF0aC5tYXgodEhlYWRlckxlbmd0aCwgbXVsdGlIZWFkZXJMZW5ndGgsIGtleXMubGVuZ3RoKQ0KICAgICAgICAgIC8vIOesrOS4gOS4quWFg+e0oOS4unRpdGxl77yM5Ymp5L2Z5Lul56m65a2X56ym5Liy5aGr5YWFDQogICAgICAgICAgdGl0bGUgPSBbdGl0bGVdLmNvbmNhdChBcnJheSh0aXRsZUxlbmd0aCAtIDEpLmZpbGwoJycpKQ0KICAgICAgICAgIC8vIOWkhOeQhuagh+mimOeahOWQiOW5tlwNCiAgICAgICAgICBjb25zdCBjZWxsPVsnQScsJ0InLCdDJywnRCcsJ0UnLCdGJywnRycsJ0gnLCdJJywnSicsJ0snLCdMJywnTScsJ04nLCdPJywnUCcsJ1EnLCdSJywnUycsJ1QnLCdVJywnVicsJ1cnLCdYJywnWScsJ1onXQ0KICAgICAgICAgIGxldCBtZXJnZVNlY29uZD0nQTEnDQogICAgICAgICAgaWYodGl0bGVMZW5ndGg+MjYpew0KICAgICAgICAgICAgIGNvbnN0IG9uZT1wYXJzZUludCh0aXRsZUxlbmd0aC8yNikNCiAgICAgICAgICAgICBjb25zdCB0d289dGl0bGVMZW5ndGglMjYNCiAgICAgICAgICAgICBtZXJnZVNlY29uZD1jZWxsW29uZS0xXStjZWxsW3R3by0xXSsnMScNCiAgICAgICAgICB9ZWxzZXsNCiAgICAgICAgICAgICBtZXJnZVNlY29uZCA9IGNlbGxbdGl0bGVMZW5ndGgtMV0rJzEnDQogICAgICAgICAgfQ0KICAgICAgICAgIGNvbnN0IHRpdGxlTWVyZ2UgPSBgQTE6JHttZXJnZVNlY29uZH1gDQogICAgICAgICAgaWYgKCFtZXJnZXMpIHsNCiAgICAgICAgICAgIG1lcmdlcyA9IFt0aXRsZU1lcmdlXQ0KICAgICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgICBpZiAobWVyZ2VzLmluZGV4T2YodGl0bGVNZXJnZSkgPT09IC0xKSB7DQogICAgICAgICAgICAgIG1lcmdlcy5wdXNoKHRpdGxlTWVyZ2UpDQogICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgICB9DQogICAgICAgIC8v6KGo5aS05a+55bqU5a2X5q61DQogICAgICAgIGxldCBkYXRhID0gdGFibGUubWFwKHYgPT4ga2V5cy5tYXAoaiA9PiB2W2pdKSkNCiAgICAgICAgLy8g5aSa57qn6KGo5aS0DQogICAgICAgIGlmIChtdWx0aUhlYWRlcikgew0KICAgICAgICAgIC8vIOWAkuW6j+W+queOrw0KICAgICAgICAgIGZvciAobGV0IGkgPSBtdWx0aUhlYWRlci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgew0KICAgICAgICAgICAgZGF0YS51bnNoaWZ0KG11bHRpSGVhZGVyW2ldKTsNCiAgICAgICAgICB9DQogICAgICAgIH0NCiAgICAgICAgdEhlYWRlciAmJiBkYXRhLnVuc2hpZnQodEhlYWRlcik7DQogICAgICAgIHRpdGxlICYmIGRhdGEudW5zaGlmdCh0aXRsZSk7DQogICAgICAgIGNvbnN0IHdzID0gdGhpcy5zaGVldF9mcm9tX2FycmF5X29mX2FycmF5cyhkYXRhKTsNCiAgICAgICAgaWYgKG1lcmdlcyAmJiBtZXJnZXMubGVuZ3RoID4gMCkgew0KICAgICAgICAgIGlmICghd3NbJyFtZXJnZXMnXSkgd3NbJyFtZXJnZXMnXSA9IFtdOw0KICAgICAgICAgIG1lcmdlcy5mb3JFYWNoKG1lcmdlID0+IHsNCiAgICAgICAgICAgIHdzWychbWVyZ2VzJ10ucHVzaChYTFNYLnV0aWxzLmRlY29kZV9yYW5nZShtZXJnZSkpDQogICAgICAgICAgfSkNCiAgICAgICAgfQ0KICAgICAgICAvLyDlpoLmnpzmsqHmnInliJflrr3liJnoh6rpgILlupQNCiAgICAgICAgaWYgKCFjb2xXaWR0aCkgew0KICAgICAgICAgIC8vIOWfuuWHhuavlOS+i++8jOS7pTEy5Li65qCH5YeGDQogICAgICAgICAgY29uc3QgYmVuY2htYXJrUmF0ZSA9IGdsb2JhbFN0eWxlLmZvbnQuc3ogJiYgZ2xvYmFsU3R5bGUuZm9udC5zeiAvIDEyIHx8IDENCiAgICAgICAgICAvLyDnqbrlrZfnrKbplb/luqYNCiAgICAgICAgICBjb25zdCBudWxsc3RyID0gMTAgKiBiZW5jaG1hcmtSYXRlICsgMg0KICAgICAgICAgIC8vIOWNleS4quS4reaWh+Wtl+espumVv+W6pg0KICAgICAgICAgIGNvbnN0IGNoaW5lc2UgPSAyICogYmVuY2htYXJrUmF0ZQ0KICAgICAgICAgIC8vIOWNleS4qumdnuS4reaWh+Wtl+espumVv+W6pg0KICAgICAgICAgIGNvbnN0IG5DaGluZXNlID0gYmVuY2htYXJrUmF0ZQ0KICAgICAgICAgIC8v6K6+572ud29ya3NoZWV05q+P5YiX55qE5pyA5aSn5a695bqmLOW5tisy6LCD5pW05LiA54K55YiX5a69DQogICAgICAgICAgY29uc3Qgc2hlZXRDb2xXaWR0aCA9IGRhdGEubWFwKHJvdyA9PiByb3cubWFwKHZhbCA9PiB7DQogICAgICAgICAgICAvL+WFiOWIpOaWreaYr+WQpuS4um51bGwvdW5kZWZpbmVkDQogICAgICAgICAgICBpZiAoIXZhbCkgew0KICAgICAgICAgICAgICByZXR1cm4gew0KICAgICAgICAgICAgICAgICd3Y2gnOiBudWxsc3RyDQogICAgICAgICAgICAgIH07DQogICAgICAgICAgICB9IGVsc2Ugew0KICAgICAgICAgICAgICBjb25zdCBzdHJBcnIgPSB2YWwudG9TdHJpbmcoKS5zcGxpdCgnJykNCiAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAoIltcdTRFMDAtXHU5RkE1XSsiKQ0KICAgICAgICAgICAgICBsZXQgcmUgPSBzdHJBcnIubWFwKHN0ciA9PiB7DQogICAgICAgICAgICAgICAgLy8g5piv5ZCm5Li65Lit5paHDQogICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4udGVzdChzdHIpKSB7DQogICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbmVzZQ0KICAgICAgICAgICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgICAgICAgICByZXR1cm4gbkNoaW5lc2UNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgIH0pDQogICAgICAgICAgICAgIHJlID0gcmUucmVkdWNlKCh0b3RhbCwgcikgPT4gdG90YWwgKyByLCAwKQ0KICAgICAgICAgICAgICByZXR1cm4gew0KICAgICAgICAgICAgICAgICd3Y2gnOiByZSArIDINCiAgICAgICAgICAgICAgfTsNCiAgICAgICAgICAgIH0NCiAgICAgICAgICB9KSkNCiAgICAgICAgICAvKuS7peesrOS4gOihjOS4uuWIneWni+WAvCovDQogICAgICAgICAgbGV0IHJlc3VsdCA9IHNoZWV0Q29sV2lkdGhbMF07DQogICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzaGVldENvbFdpZHRoLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNoZWV0Q29sV2lkdGhbaV0ubGVuZ3RoOyBqKyspIHsNCiAgICAgICAgICAgICAgaWYgKHJlc3VsdFtqXVsnd2NoJ10gPCBzaGVldENvbFdpZHRoW2ldW2pdWyd3Y2gnXSkgew0KICAgICAgICAgICAgICAgIHJlc3VsdFtqXVsnd2NoJ10gPSBzaGVldENvbFdpZHRoW2ldW2pdWyd3Y2gnXTsNCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCiAgICAgICAgICB3c1snIWNvbHMnXSA9IHJlc3VsdDsNCiAgICAgICAgfSBlbHNlIHsNCiAgICAgICAgICB3c1snIWNvbHMnXSA9IGNvbFdpZHRoLm1hcChpID0+IHsNCiAgICAgICAgICAgIHJldHVybiB7IHdjaDogaSB9DQogICAgICAgICAgfSkNCiAgICAgICAgfQ0KDQogICAgICAgIC8vIOa3u+WKoOW3peS9nOihqA0KICAgICAgICB3Yi5TaGVldE5hbWVzLnB1c2goc2hlZXROYW1lKTsNCiAgICAgICAgd2IuU2hlZXRzW3NoZWV0TmFtZV0gPSB3czsNCiAgICAgICAgbGV0IGRhdGFJbmZvID0gd2IuU2hlZXRzW3diLlNoZWV0TmFtZXNbaW5kZXhdXTsNCg0KICAgICAgICAvL+WFqOWxgOagt+W8jw0KICAgICAgICAoZnVuY3Rpb24gKCkgew0KICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGFJbmZvKS5mb3JFYWNoKGkgPT4gew0KICAgICAgICAgICAgaWYgKGkgPT0gJyFyZWYnIHx8IGkgPT0gJyFtZXJnZXMnIHx8IGkgPT0gJyFjb2xzJykgew0KICAgICAgICAgICAgfSBlbHNlIHsNCiAgICAgICAgICAgICAgZGF0YUluZm9baS50b1N0cmluZygpXS5zID0gZ2xvYmFsU3R5bGU7DQogICAgICAgICAgICB9DQogICAgICAgICAgfSk7DQogICAgICAgIH0pKCk7DQoNCiAgICAgICAgLy8g5Y2V5Liq5qC35byPDQogICAgICAgIChmdW5jdGlvbiAoKSB7DQogICAgICAgICAgaWYgKCFjZWxsU3R5bGUgfHwgY2VsbFN0eWxlLmxlbmd0aCA8PSAwKSB7DQogICAgICAgICAgICByZXR1cm4NCiAgICAgICAgICB9DQogICAgICAgICAgY2VsbFN0eWxlLmZvckVhY2gocyA9PiB7DQogICAgICAgICAgICBjb25zdCB7IGJvcmRlciwgZm9udCwgYWxpZ25tZW50LCBmaWxsIH0gPSBzOw0KICAgICAgICAgICAgZGF0YUluZm9bcy5jZWxsXS5zID0gew0KICAgICAgICAgICAgICBib3JkZXI6IGJvcmRlciA9PT0ge30gPyBib3JkZXIgOiBib3JkZXIgfHwgZ2xvYmFsU3R5bGUuYm9yZGVyLA0KICAgICAgICAgICAgICBmb250OiBmb250IHx8IGdsb2JhbFN0eWxlLmZvbnQsDQogICAgICAgICAgICAgIGFsaWdubWVudDogYWxpZ25tZW50IHx8IGdsb2JhbFN0eWxlLmFsaWdubWVudCwNCiAgICAgICAgICAgICAgZmlsbDogZmlsbCB8fCBnbG9iYWxTdHlsZS5maWxsDQogICAgICAgICAgICB9DQogICAgICAgICAgfSk7DQogICAgICAgIH0pKCk7DQogICAgICB9KQ0KICAgICAgLy8g57G75Z6L6buY6K6k5Li6eGxzeA0KICAgICAgbGV0IGJvb2tUeXBlID0gdGhpcy5lbnVtLmJvb2tUeXBlLmZpbHRlcihpID0+IGkgPT09IHRoaXMuYm9va1R5cGUpWzBdIHx8IHRoaXMuZW51bS5ib29rVHlwZVswXTsNCiAgICAgIHRoaXMud3JpdGVFeGNlbCh3YiwgYm9va1R5cGUsIHRoaXMuZmlsZW5hbWUpDQogICAgfSwNCiAgICAvKioNCiAgICAgKiBAbmFtZTogd29ya2Jvb2vlr7nosaENCiAgICAgKiBAcGFyYW0ge3R5cGV9IA0KICAgICAqIEByZXR1cm46IA0KICAgICAqLw0KICAgIFdvcmtib29rICgpIHsNCiAgICAgIGNsYXNzIFdCIHsNCiAgICAgICAgY29uc3RydWN0b3IoKSB7DQogICAgICAgICAgdGhpcy5TaGVldE5hbWVzID0gW107DQogICAgICAgICAgdGhpcy5TaGVldHMgPSB7fTsNCiAgICAgICAgfQ0KICAgICAgfQ0KICAgICAgcmV0dXJuIG5ldyBXQigpDQogICAgfSwNCiAgICAvKioNCiAgICAgKiBAbmFtZTog5a+85Ye6ZXhjZWzmlofku7YNCiAgICAgKiBAcGFyYW0ge3R5cGV9IA0KICAgICAqIEByZXR1cm46IA0KICAgICAqLw0KICAgIHdyaXRlRXhjZWwgKHdiLCBib29rVHlwZSwgZmlsZW5hbWUpIHsNCiAgICAgIGNvbnN0IHdib3V0ID0gWExTWC53cml0ZSh3Yiwgew0KICAgICAgICBib29rVHlwZTogYm9va1R5cGUsDQogICAgICAgIGJvb2tTU1Q6IGZhbHNlLA0KICAgICAgICB0eXBlOiAnYmluYXJ5Jw0KICAgICAgfSk7DQogICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW3RoaXMuczJhYih3Ym91dCldLCB7DQogICAgICAgIHR5cGU6ICJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0iDQogICAgICB9KQ0KICAgICAgY29uc3QgYmVmb3JlRXhwb3J0ID0gdGhpcy5iZWZvcmVFeHBvcnQoYmxvYiwgYm9va1R5cGUsIGZpbGVuYW1lKQ0KICAgICAgaWYgKGJlZm9yZUV4cG9ydCA9PT0gZmFsc2UpIHsNCiAgICAgICAgcmV0dXJuDQogICAgICB9DQogICAgICBzYXZlQXMoYmxvYiwgYCR7ZmlsZW5hbWV9LiR7Ym9va1R5cGV9YCk7DQogICAgfSwNCiAgICAvKioNCiAgICAgKiBAbmFtZTog6L2s5YyW5pe26Ze05qC85byPDQogICAgICogQHBhcmFtIHt0eXBlfSANCiAgICAgKiBAcmV0dXJuOiANCiAgICAgKi8NCiAgICBkYXRlbnVtICh2LCBkYXRlMTkwNCkgew0KICAgICAgaWYgKGRhdGUxOTA0KSB2ICs9IDE0NjI7DQogICAgICBjb25zdCBlcG9jaCA9IERhdGUucGFyc2Uodik7DQogICAgICByZXR1cm4gKGVwb2NoIC0gbmV3IERhdGUoRGF0ZS5VVEMoMTg5OSwgMTEsIDMwKSkpIC8gKDI0ICogNjAgKiA2MCAqIDEwMDApOw0KICAgIH0sDQogICAgLyoqDQogICAgICogQG5hbWU6IOiuvue9ruaVsOaNruexu+Weiw0KICAgICAqIEBwYXJhbSB7dHlwZX0gDQogICAgICogQHJldHVybjogDQogICAgICovDQogICAgc2hlZXRfZnJvbV9hcnJheV9vZl9hcnJheXMgKGRhdGEsIG9wdHMpIHsNCiAgICAgIGxldCB3cyA9IHt9Ow0KICAgICAgY29uc3QgcmFuZ2UgPSB7DQogICAgICAgIHM6IHsNCiAgICAgICAgICBjOiAxMDAwMDAwMDAwLA0KICAgICAgICAgIHI6IDEwMDAwMDAwMDANCiAgICAgICAgfSwNCiAgICAgICAgZTogew0KICAgICAgICAgIGM6IDAsDQogICAgICAgICAgcjogMA0KICAgICAgICB9DQogICAgICB9Ow0KICAgICAgZm9yIChsZXQgUiA9IDA7IFIgIT0gZGF0YS5sZW5ndGg7ICsrUikgew0KICAgICAgICBmb3IgKGxldCBDID0gMDsgQyAhPSBkYXRhW1JdLmxlbmd0aDsgKytDKSB7DQogICAgICAgICAgaWYgKHJhbmdlLnMuciA+IFIpIHJhbmdlLnMuciA9IFI7DQogICAgICAgICAgaWYgKHJhbmdlLnMuYyA+IEMpIHJhbmdlLnMuYyA9IEM7DQogICAgICAgICAgaWYgKHJhbmdlLmUuciA8IFIpIHJhbmdlLmUuciA9IFI7DQogICAgICAgICAgaWYgKHJhbmdlLmUuYyA8IEMpIHJhbmdlLmUuYyA9IEM7DQogICAgICAgICAgbGV0IGNlbGwgPSB7DQogICAgICAgICAgICB2OiBkYXRhW1JdW0NdDQogICAgICAgICAgfTsNCiAgICAgICAgICBpZiAoY2VsbC52ID09IG51bGwpIGNvbnRpbnVlOw0KICAgICAgICAgIGxldCBjZWxsX3JlZiA9IFhMU1gudXRpbHMuZW5jb2RlX2NlbGwoew0KICAgICAgICAgICAgYzogQywNCiAgICAgICAgICAgIHI6IFINCiAgICAgICAgICB9KTsNCg0KICAgICAgICAgIGlmICh0eXBlb2YgY2VsbC52ID09PSAnbnVtYmVyJykgY2VsbC50ID0gJ24nOw0KICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjZWxsLnYgPT09ICdib29sZWFuJykgY2VsbC50ID0gJ2InOw0KICAgICAgICAgIGVsc2UgaWYgKGNlbGwudiBpbnN0YW5jZW9mIERhdGUpIHsNCiAgICAgICAgICAgIGNlbGwudCA9ICduJzsNCiAgICAgICAgICAgIGNlbGwueiA9IFhMU1guU1NGLl90YWJsZVsxNF07DQogICAgICAgICAgICBjZWxsLnYgPSB0aGlzLmRhdGVudW0oY2VsbC52KTsNCiAgICAgICAgICB9IGVsc2UgY2VsbC50ID0gJ3MnOw0KDQogICAgICAgICAgd3NbY2VsbF9yZWZdID0gY2VsbDsNCiAgICAgICAgfQ0KICAgICAgfQ0KICAgICAgaWYgKHJhbmdlLnMuYyA8IDEwMDAwMDAwMDApIHdzWychcmVmJ10gPSBYTFNYLnV0aWxzLmVuY29kZV9yYW5nZShyYW5nZSk7DQogICAgICByZXR1cm4gd3M7DQogICAgfSwNCg0KICAgIC8qKg0KICAgICAqIEBuYW1lOiDovazmjaLmoLzlvI8NCiAgICAgKiBAcGFyYW0ge3R5cGV9IA0KICAgICAqIEByZXR1cm46IA0KICAgICAqLw0KICAgIHMyYWIgKHMpIHsNCiAgICAgIGNvbnN0IGIgPSBuZXcgQXJyYXlCdWZmZXIocy5sZW5ndGgpOw0KICAgICAgY29uc3QgdiA9IG5ldyBVaW50OEFycmF5KGIpOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7DQogICAgICAgIHZbaV0gPSBzLmNoYXJDb2RlQXQoaSkgJiAweEZGDQogICAgICB9DQogICAgICByZXR1cm4gYjsNCiAgICB9DQogIH0sDQogIGNvbXB1dGVkOiB7fSwNCiAgd2F0Y2g6IHt9LA0KfQ0K"},{"version":3,"sources":["excelExport.vue"],"names":[],"mappings":";;;;;;;;;;;;;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"excelExport.vue","sourceRoot":"src/plugin/excelExport","sourcesContent":["<!--\r\n * @Author: zouzheng\r\n * @Date: 2020-04-30 11:42:13\r\n * @LastEditors: zouzheng\r\n * @LastEditTime: 2020-08-10 23:10:18\r\n * @Description: 这是excel导出组件（页面）\r\n -->\r\n<template>\r\n  <div class=\"excel-export\" @click=\"!manual&&exportExcel()\">\r\n    <slot></slot>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { saveAs } from 'file-saver'\r\nimport XLSX from 'pikaz-xlsx-style'\r\nexport default {\r\n  props: {\r\n    // 文件类型\r\n    bookType: {\r\n      type: String,\r\n      default: 'xlsx'\r\n    },\r\n    // 文件名\r\n    filename: {\r\n      type: String,\r\n      default: 'excel'\r\n    },\r\n    // 是否手动导出\r\n    manual: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    // 表格配置\r\n    sheet: {\r\n      type: Array,\r\n      default: () => {\r\n        return []\r\n      }\r\n    },\r\n    // 处理数据前\r\n    beforeStart: {\r\n      type: Function,\r\n      // bookType:文件类型,filename:文件名,sheet:表格数据\r\n      default: (bookType, filename, sheet) => { }\r\n    },\r\n    // 导出前\r\n    beforeExport: {\r\n      type: Function,\r\n      // filename:文件名,sheet:表格数据,blob:文件流\r\n      default: (bookType, filename, blob) => { }\r\n    },\r\n    // 导出错误\r\n    onError: {\r\n      type: Function,\r\n      // err:错误信息\r\n      default: (err) => { }\r\n    }\r\n  },\r\n  components: {},\r\n  data () {\r\n    return {\r\n      // 默认配置\r\n      default: {\r\n        sheetName: 'sheet',\r\n        globalStyle: {\r\n          border: {\r\n            top: {\r\n              style: 'thin',\r\n              color: { rgb: \"000000\" }\r\n            },\r\n            bottom: {\r\n              style: 'thin',\r\n              color: { rgb: \"000000\" }\r\n            },\r\n            left: {\r\n              style: 'thin',\r\n              color: { rgb: \"000000\" }\r\n            },\r\n            right: {\r\n              style: 'thin',\r\n              color: { rgb: \"000000\" }\r\n            }\r\n          },\r\n          font: {\r\n            name: '宋体',\r\n            sz: 12,\r\n            color: { rgb: \"000000\" },\r\n            bold: false,\r\n            italic: false,\r\n            underline: false,\r\n            shadow: false\r\n          },\r\n          alignment: {\r\n            horizontal: \"center\",\r\n            vertical: \"center\",\r\n            wrapText: false\r\n          },\r\n          fill: {\r\n            fgColor: { rgb: \"ffffff\" },\r\n          }\r\n        },\r\n      },\r\n      // 枚举类\r\n      enum: {\r\n        // 文件类型\r\n        bookType: ['xlsx', 'xls']\r\n      }\r\n    }\r\n  },\r\n  created () {\r\n  },\r\n  mounted () {\r\n  },\r\n  methods: {\r\n    /**\r\n     * @name: 导出excel函数\r\n     * @param {type} \r\n     * @return: \r\n     */\r\n    pikaExportExcel () {\r\n      this.$nextTick(() => {\r\n        this.exportExcel()\r\n      })\r\n    },\r\n    /**\r\n     * @name:导出excel \r\n     * @param {type} \r\n     * @return: \r\n     */\r\n    exportExcel () {\r\n      // 处理数据前\r\n      const beforeStart = this.beforeStart(this.bookType, this.filename, this.sheet)\r\n      if (beforeStart === false) {\r\n        return\r\n      }\r\n      if (!this.sheet || this.sheet.length <= 0) {\r\n        this.onError('Table data cannot be empty')\r\n        return\r\n      }\r\n      const wb = this.Workbook()\r\n      this.sheet.forEach((item, index) => {\r\n        let {\r\n          // 标题\r\n          title,\r\n          // 表头\r\n          tHeader,\r\n          // 多级表头\r\n          multiHeader,\r\n          // 表格数据\r\n          table,\r\n          // 合并项\r\n          merges,\r\n          // 数据键值\r\n          keys,\r\n          // 列宽\r\n          colWidth,\r\n          // 表名\r\n          sheetName,\r\n          // 全局样式\r\n          globalStyle,\r\n          // 单元格样式\r\n          cellStyle\r\n        } = item\r\n        sheetName = sheetName || this.default.sheetName\r\n        // 默认全局样式覆盖\r\n        const dgStyle = this.default.globalStyle\r\n        if (globalStyle) {\r\n          Object.keys(dgStyle).forEach(key => {\r\n            globalStyle[key] = { ...dgStyle[key], ...globalStyle[key] }\r\n          })\r\n        } else {\r\n          globalStyle = dgStyle\r\n        }\r\n        // 处理标题格式\r\n        if (title || title === 0 || title === '') {\r\n          // 取表头、多级表头中的最大值\r\n          const tHeaderLength = tHeader && tHeader.length || 0\r\n          const multiHeaderLength = multiHeader && Math.max(...multiHeader.map(m => m.length)) || 0\r\n          const titleLength = Math.max(tHeaderLength, multiHeaderLength, keys.length)\r\n          // 第一个元素为title，剩余以空字符串填充\r\n          title = [title].concat(Array(titleLength - 1).fill(''))\r\n          // 处理标题的合并\\\r\n          const cell=['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']\r\n          let mergeSecond='A1'\r\n          if(titleLength>26){\r\n             const one=parseInt(titleLength/26)\r\n             const two=titleLength%26\r\n             mergeSecond=cell[one-1]+cell[two-1]+'1'\r\n          }else{\r\n             mergeSecond = cell[titleLength-1]+'1'\r\n          }\r\n          const titleMerge = `A1:${mergeSecond}`\r\n          if (!merges) {\r\n            merges = [titleMerge]\r\n          } else {\r\n            if (merges.indexOf(titleMerge) === -1) {\r\n              merges.push(titleMerge)\r\n            }\r\n          }\r\n        }\r\n        //表头对应字段\r\n        let data = table.map(v => keys.map(j => v[j]))\r\n        // 多级表头\r\n        if (multiHeader) {\r\n          // 倒序循环\r\n          for (let i = multiHeader.length - 1; i >= 0; i--) {\r\n            data.unshift(multiHeader[i]);\r\n          }\r\n        }\r\n        tHeader && data.unshift(tHeader);\r\n        title && data.unshift(title);\r\n        const ws = this.sheet_from_array_of_arrays(data);\r\n        if (merges && merges.length > 0) {\r\n          if (!ws['!merges']) ws['!merges'] = [];\r\n          merges.forEach(merge => {\r\n            ws['!merges'].push(XLSX.utils.decode_range(merge))\r\n          })\r\n        }\r\n        // 如果没有列宽则自适应\r\n        if (!colWidth) {\r\n          // 基准比例，以12为标准\r\n          const benchmarkRate = globalStyle.font.sz && globalStyle.font.sz / 12 || 1\r\n          // 空字符长度\r\n          const nullstr = 10 * benchmarkRate + 2\r\n          // 单个中文字符长度\r\n          const chinese = 2 * benchmarkRate\r\n          // 单个非中文字符长度\r\n          const nChinese = benchmarkRate\r\n          //设置worksheet每列的最大宽度,并+2调整一点列宽\r\n          const sheetColWidth = data.map(row => row.map(val => {\r\n            //先判断是否为null/undefined\r\n            if (!val) {\r\n              return {\r\n                'wch': nullstr\r\n              };\r\n            } else {\r\n              const strArr = val.toString().split('')\r\n              const pattern = new RegExp(\"[\\u4E00-\\u9FA5]+\")\r\n              let re = strArr.map(str => {\r\n                // 是否为中文\r\n                if (pattern.test(str)) {\r\n                  return chinese\r\n                } else {\r\n                  return nChinese\r\n                }\r\n              })\r\n              re = re.reduce((total, r) => total + r, 0)\r\n              return {\r\n                'wch': re + 2\r\n              };\r\n            }\r\n          }))\r\n          /*以第一行为初始值*/\r\n          let result = sheetColWidth[0];\r\n          for (let i = 1; i < sheetColWidth.length; i++) {\r\n            for (let j = 0; j < sheetColWidth[i].length; j++) {\r\n              if (result[j]['wch'] < sheetColWidth[i][j]['wch']) {\r\n                result[j]['wch'] = sheetColWidth[i][j]['wch'];\r\n              }\r\n            }\r\n          }\r\n          ws['!cols'] = result;\r\n        } else {\r\n          ws['!cols'] = colWidth.map(i => {\r\n            return { wch: i }\r\n          })\r\n        }\r\n\r\n        // 添加工作表\r\n        wb.SheetNames.push(sheetName);\r\n        wb.Sheets[sheetName] = ws;\r\n        let dataInfo = wb.Sheets[wb.SheetNames[index]];\r\n\r\n        //全局样式\r\n        (function () {\r\n          Object.keys(dataInfo).forEach(i => {\r\n            if (i == '!ref' || i == '!merges' || i == '!cols') {\r\n            } else {\r\n              dataInfo[i.toString()].s = globalStyle;\r\n            }\r\n          });\r\n        })();\r\n\r\n        // 单个样式\r\n        (function () {\r\n          if (!cellStyle || cellStyle.length <= 0) {\r\n            return\r\n          }\r\n          cellStyle.forEach(s => {\r\n            const { border, font, alignment, fill } = s;\r\n            dataInfo[s.cell].s = {\r\n              border: border === {} ? border : border || globalStyle.border,\r\n              font: font || globalStyle.font,\r\n              alignment: alignment || globalStyle.alignment,\r\n              fill: fill || globalStyle.fill\r\n            }\r\n          });\r\n        })();\r\n      })\r\n      // 类型默认为xlsx\r\n      let bookType = this.enum.bookType.filter(i => i === this.bookType)[0] || this.enum.bookType[0];\r\n      this.writeExcel(wb, bookType, this.filename)\r\n    },\r\n    /**\r\n     * @name: workbook对象\r\n     * @param {type} \r\n     * @return: \r\n     */\r\n    Workbook () {\r\n      class WB {\r\n        constructor() {\r\n          this.SheetNames = [];\r\n          this.Sheets = {};\r\n        }\r\n      }\r\n      return new WB()\r\n    },\r\n    /**\r\n     * @name: 导出excel文件\r\n     * @param {type} \r\n     * @return: \r\n     */\r\n    writeExcel (wb, bookType, filename) {\r\n      const wbout = XLSX.write(wb, {\r\n        bookType: bookType,\r\n        bookSST: false,\r\n        type: 'binary'\r\n      });\r\n      const blob = new Blob([this.s2ab(wbout)], {\r\n        type: \"application/octet-stream\"\r\n      })\r\n      const beforeExport = this.beforeExport(blob, bookType, filename)\r\n      if (beforeExport === false) {\r\n        return\r\n      }\r\n      saveAs(blob, `${filename}.${bookType}`);\r\n    },\r\n    /**\r\n     * @name: 转化时间格式\r\n     * @param {type} \r\n     * @return: \r\n     */\r\n    datenum (v, date1904) {\r\n      if (date1904) v += 1462;\r\n      const epoch = Date.parse(v);\r\n      return (epoch - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1000);\r\n    },\r\n    /**\r\n     * @name: 设置数据类型\r\n     * @param {type} \r\n     * @return: \r\n     */\r\n    sheet_from_array_of_arrays (data, opts) {\r\n      let ws = {};\r\n      const range = {\r\n        s: {\r\n          c: 1000000000,\r\n          r: 1000000000\r\n        },\r\n        e: {\r\n          c: 0,\r\n          r: 0\r\n        }\r\n      };\r\n      for (let R = 0; R != data.length; ++R) {\r\n        for (let C = 0; C != data[R].length; ++C) {\r\n          if (range.s.r > R) range.s.r = R;\r\n          if (range.s.c > C) range.s.c = C;\r\n          if (range.e.r < R) range.e.r = R;\r\n          if (range.e.c < C) range.e.c = C;\r\n          let cell = {\r\n            v: data[R][C]\r\n          };\r\n          if (cell.v == null) continue;\r\n          let cell_ref = XLSX.utils.encode_cell({\r\n            c: C,\r\n            r: R\r\n          });\r\n\r\n          if (typeof cell.v === 'number') cell.t = 'n';\r\n          else if (typeof cell.v === 'boolean') cell.t = 'b';\r\n          else if (cell.v instanceof Date) {\r\n            cell.t = 'n';\r\n            cell.z = XLSX.SSF._table[14];\r\n            cell.v = this.datenum(cell.v);\r\n          } else cell.t = 's';\r\n\r\n          ws[cell_ref] = cell;\r\n        }\r\n      }\r\n      if (range.s.c < 1000000000) ws['!ref'] = XLSX.utils.encode_range(range);\r\n      return ws;\r\n    },\r\n\r\n    /**\r\n     * @name: 转换格式\r\n     * @param {type} \r\n     * @return: \r\n     */\r\n    s2ab (s) {\r\n      const b = new ArrayBuffer(s.length);\r\n      const v = new Uint8Array(b);\r\n      for (let i = 0; i < s.length; i++) {\r\n        v[i] = s.charCodeAt(i) & 0xFF\r\n      }\r\n      return b;\r\n    }\r\n  },\r\n  computed: {},\r\n  watch: {},\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n</style>"]}]}